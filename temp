目前workflow的设计中：
1、component中除了CI脚本之外，还需要编写额外的代码发送http请求，
	一方面是告知component的运行情况，另外还需要发送相关日志信息。
2、component中需要启动http服务端进程，让workflow往component发送http请求数据
3、workflow不断轮询数据库，查询component的状态是否成功，效率较低

作为用户一般只关注用户项目的构建脚本内容，
目前定义了component start，task start，task status，task result和component stop这些事件，
用户可能不太了解这些事件的真实定义，同时也增加了component的复杂性

现在的需求是：
workflow需要了解component的运行情况和结果
workflow需要获取component的日志
workflow需要向component发送输入数据
component需要向workflow发送输出数据

修改方案：
1、workflow启动component，使用k8s的pod，同时监听这个pod的变更事件（观察者模式，无需轮询），设置超时时间
	pod在超时时间内结束：
	根据container的exit code作为component的运行结果
	pod未在超时时间内结束：
	设置component运行结果为失败
	最后，取消监听事件，删除对应的pod
	使用exit code的好处：通用并为大多数人熟悉（默认：0为成功，其他为失败）
						 几乎所有代码中都能设置exit code
2、将docker的container标准输出和错误输出配置到syslog服务器
	component的输出数据和相关日志都直接打印到标准输出和错误输出
	syslog可以将这部分数据发送到日志系统中，进行展现和搜索
	对于按照约定格式的输出数据，syslog将发送到消息队列中，
	workflow订阅消息队列相关事件，获取到数据则作为对应component的输入
	使用syslog和消息队列的好处：component的日志不再需要通过http发送
								消息队列提供了订阅功能同时保证系统间的隔离
								workflow只需要负责component的编排功能
3、component需要的输入数据，在启动的时候即通过环境变量或者command参数传递
	并不需要在启动后再通知workflow传入
